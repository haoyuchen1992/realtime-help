# Copyright 2014 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Services for the chat XBlock.."""

__author__ = 'Sean Lip (sll@google.com)'

import random
import time


# The maximum value of a room id. A room id is generated by picking a number at
# random in the range [0, MAX_ROOM_ID].
MAX_ROOM_ID = 9999
# The maximum number of retries to generate a new room id.
MAX_RETRIES = 10
# The maximum number of students to notify when a request for help comes in.
MAX_STUDENTS_TO_NOTIFY = 5


class ChatXBlockError(Exception):
    """An exception raised for generic errors."""
    pass


class RoomGenerationError(Exception):
    """An exception that is raised if a new room cannot be generated."""
    pass


class Chat(object):
    """Service methods for the chat XBlock."""

    def __init__(self, chat_provider):
        self.chat_provider = chat_provider

    def _get_new_room_id(self):
        """Returns an id (of type str) for a currently-inactive room."""
        active_rooms = self.chat_provider.get_active_room_list()

        found_room = False
        for _ in range(MAX_RETRIES):
            room_id = 'room-%s' % random.randint(0, MAX_ROOM_ID)
            if room_id not in active_rooms:
                found_room = True
                break

        if not found_room:
            raise RoomGenerationError(
                'Could not generate new room after %s tries.' % MAX_RETRIES)

        return room_id

    def _construct_invitation_stanza(
            self, room_id, asker_id, asker_href, message_text):
        """Constructs a stanza to send to recipients of the question.

        Note that the asker_href may end with #.

        Args:
          room_id: str. A room id.
          asker_id: str. The user_id of the asker.
          asker_href: str. The URL of the webpage that the asker is asking the
            question from.
          message_text: str. The text of the message to send to the recipient.
        """
        if asker_href.endswith('#'):
            dest_href = '%s%s' % (asker_href, room_id)
        else:
            dest_href = '%s#%s' % (asker_href, room_id)

        return (
            '<room_id>%s</room_id><asker_id>%s</asker_id>'
            '<asker_href>%s</asker_href>%s'
        ) % (room_id, asker_id, dest_href, message_text)

    def _clean_room_if_empty(self, room_id, room_id_to_owner_display_name):
        """Given a candidate room, check if it's empty, and if so, clean it.

        Note that this uses the chat server's records to update the records
        for this XBlock.

        Args:
          room_id: str. A room id.
          room_id_to_owner_display_name: An XBlock field or a dict representing
            a mapping of room ids to their owner display names.
        """
        room_occupants = self.chat_provider.get_room_occupants(room_id)
        if len(room_occupants) == 0:
            if room_id in room_id_to_owner_display_name:
                del room_id_to_owner_display_name[room_id]

    def handle_invitation_acceptance(
            self, user_id, room_id, user_id_to_room_id,
            user_id_to_room_invitations):
        """Process a user accepting an invitation to a room.

        More specifically, this clears all other invitations and assigns the
        user to the given room.
        """
        invitations = user_id_to_room_invitations.get(user_id, [])
        invited = any([
            invitation['room_id'] == room_id for invitation in invitations])
        if not invited:
            raise ChatXBlockError(
                'You do not have an invitation to room %s.' % room_id)

        user_id_to_room_invitations[user_id] = []
        user_id_to_room_id[user_id] = room_id

    def handle_start_new_chat(
            self, user_id, asker_display_name, asker_location, asker_question,
            user_id_to_room_id, room_id_to_owner_display_name,
            user_id_to_room_invitations):
        """Process a user starting a new chat."""
        try:
            room_id = self._get_new_room_id()
        except RoomGenerationError:
            raise ChatXBlockError(
                'Capacity error; could not assign new room.')

        # Select invitees and send messages to them.
        candidate_invitee_jids = self.chat_provider.get_helper_jids(user_id)
        num_invitees = 0
        for invitee_jid in candidate_invitee_jids:
            invitee_id = invitee_jid[:invitee_jid.find('@')]

            # Do not send invitations to users who are already engaged
            # in another chat for this usage.
            if invitee_id in user_id_to_room_id:
                room_occupants = self.chat_provider.get_room_occupants(room_id)
                if len(room_occupants) == 0:
                    self._clean_room_if_empty(
                        room_id, room_id_to_owner_display_name)
                else:
                    continue

            if invitee_id not in user_id_to_room_invitations:
                user_id_to_room_invitations[invitee_id] = []
            user_id_to_room_invitations[invitee_id].append({
                'time_invited': int(time.time()),
                'room_id': room_id,
            })
            invitation_stanza = self._construct_invitation_stanza(
                room_id, user_id, asker_location, asker_question)
            self.chat_provider.send_message(invitee_jid, invitation_stanza)
            num_invitees += 1

            if num_invitees >= MAX_STUDENTS_TO_NOTIFY:
                break

        if num_invitees == 0:
            raise ChatXBlockError(
                'Sorry, no other students are currently available to chat.')

        # Update the XBlock fields.
        user_id_to_room_id[user_id] = room_id
        room_id_to_owner_display_name[room_id] = asker_display_name

        # While this user is asking a question, he/she cannot accept
        # invitations for other questions in the same usage.
        if user_id in user_id_to_room_invitations:
            del user_id_to_room_invitations[user_id]

        return room_id

    def handle_leave_chat(
            self, user_id, user_id_to_room_id, room_id_to_owner_display_name):
        """Handle a 'leave chat' event."""
        if user_id in user_id_to_room_id:
            room_id = user_id_to_room_id[user_id]
            del user_id_to_room_id[user_id]
            self._clean_room_if_empty(room_id, room_id_to_owner_display_name)
